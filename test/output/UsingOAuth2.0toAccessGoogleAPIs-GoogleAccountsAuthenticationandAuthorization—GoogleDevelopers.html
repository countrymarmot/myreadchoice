<article><h1 class="page-title" itemprop="name">Using OAuth 2.0 to Access Google APIs</h1><div itemprop="articleBody">
<section>
<p>Google APIs use the <a href="http://tools.ietf.org/html/draft-ietf-oauth-v2-22">OAuth 2.0
protocol</a> for authentication and authorization. Google supports common OAuth 2.0 
scenarios such as those for web server, installed, and client-side applications.</p>
<p>
OAuth 2.0 is a relatively simple protocol. 
To begin, you register your application with Google. Then your client application 
requests an access token from the Google 
Authorization Server, extracts a token from the response, and sends the token to the 
Google API that you want to access.</p>
<p>
This page gives an overview of the OAuth 2.0 authorization scenarios that Google supports, 
and provides links to more detailed content. For details about using OAuth 2.0 for 
authentication, see <a href="/accounts/docs/OAuth2Login">Using OAuth 2.0 for Login</a>.
</p>
<aside class="note"><b>Note:</b> 
Given the security implications of getting the implementation correct, we strongly encourage you to use OAuth 2.0 libraries when
interacting with Google's OAuth 2.0 endpoints. It is a best practice to use well-debugged code 
provided by others, and it will help you protect yourself and your users. For more information, 
see <a href="#libraries">Client libraries</a>. 
</aside>
</section>
<section>
<h2>Contents</h2>
<ol class="toc">
<li><a href="#basicsteps">Basic steps</a></li>
<li><a href="#scenarios">Scenarios</a>
<ol>
<li><a href="#webserver">Web server applications</a> </li>
<li><a href="#installed">Installed applications</a> </li>
<li><a href="#clientside">Client-side (JavaScript) applications</a> </li>
<li><a href="#device">Applications on limited-input devices</a> </li>
<li><a href="#serviceaccount">Service accounts</a></li>
</ol>
</li>
<li><a href="#libraries">Client libraries</a></li>
</ol>
</section>
<section>
<h2 id="basicsteps">Basic steps</h2>
<p>All applications follow a basic pattern when accessing a Google API using OAuth 2.0. At a high level, you follow four steps:
        <h4>1. Register your application.</h4>
<p>
            All applications that access a Google API must be registered through the 
<a href="https://cloud.google.com/console" target="_blank">Google Cloud Console</a>.
            The result of this registration process is a set of values (such as a client ID 
and client secret) that are known to both Google and your application. The set of values varies 
based on what type of application you are building. For example, a JavaScript application does not require a secret, but
            a web server application does.
        </p>
<h4>2. Obtain an access token from the Google Authorization Server.</h4>
<p>
          Before your application can access private data using a Google API, it must obtain an access token that grants access to that API.
          A single access token can grant varying degrees of access to multiple APIs. A variable parameter 
          called <code>scope</code> controls the set of resources and operations that an access token 
          permits. During the access-token request, your application sends one or more values in 
the <code>scope</code> parameter.
        </p>
<p>
           There are several ways to make this request, and they vary based on the type of application you are building. For example, a JavaScript application
           might request an access token using a browser redirect to Google, while an application installed on a device that has no browser uses web service requests.
        </p>
<p>
           Some requests require an authentication step where the user logs in with their Google 
account. After logging in, the user is asked 
           whether they are willing to grant the permissions that your application is requesting. 
           This process is called <dfn>user consent</dfn>.
        </p>
<p>
           If the user grants the permission, the Google Authorization Server 
sends your application an access token (or an authorization code that your application can use to obtain an access token).
           If the user does not grant the permission, the server returns an error.
        </p>
<p>




It is generally a best practice to request scopes incrementally, at the time access is required, rather than up front. For example, an app that wants to support purchases should not request Google Wallet access until the user presses the “buy” button; see <a href="/accounts/docs/OAuth2WebServer#incrementalAuth">Incremental authorization</a>.



	</p>
<h4>3. Send the access token to an API.</h4>
<p>
          After an application obtains an access token, it sends the token to a Google 
API in an HTTP authorization header. It is possible to send tokens as URI query-string parameters, 
but we don't recommend it, because URI parameters can end up in log files that are not completely 
secure. Also, it is good REST practice 
to avoid creating unnecessary URI parameter names.</p>
<p>Access tokens are valid only for the set of
          operations and resources described in the <code>scope</code> of the token request. For example, if an access token is issued for the Google+ API, it does not grant access
          to the Google Contacts API. You can, however, send that access token to the Google+ API multiple times for similar operations.
        
        </p>
<h4>4. Refresh the access token, if necessary.</h4>
<p>
            Access tokens have limited lifetimes. If your application needs access to a Google API beyond the lifetime of a single access token, 
            it can obtain a refresh token. A 
refresh token allows your application to obtain new access tokens.
        </p>
<aside class="note"><b>Note: </b>
          Save refresh tokens in secure long-term storage and continue to use them as long as they 
remain valid. Limits apply to the number of refresh tokens that are issued per client-user 
combination, and per user across all clients, and these limits are different. If your application 
requests enough refresh tokens to go over one of the limits, older refresh tokens stop working.
</aside>
</p></section>
<h2 id="scenarios">Scenarios</h2>
<h3 id="webserver">Web server applications</h3>
<p>
The Google OAuth 2.0 endpoint supports web server applications that use languages and frameworks 
such as PHP, Java, Python, Ruby, and ASP.NET.</p>
<p>
The authorization sequence begins when your application redirects 
a browser to a Google URL; the URL includes query parameters that indicate the type of access 
being requested. Google handles the user authentication, session selection, and user consent. 
The result is an authorization code, which the application can exchange for
an access token and a refresh token.
</p>
<p>
The application should store the refresh token for 
future use and use the access token to access a Google API. Once the access token expires, the 
application uses the refresh token to obtain a new one.
</p>
<figure id="fig1">
<img alt="Your application sends a token request to the Google Authorization Server, receives an authorization code, 
exchanges the code for a token, and uses the token to call a Google API endpoint." height="377px" src="/accounts/images/webflow.png" width="364px"/>
</figure>
<p>
For more information, see <a href="/accounts/docs/OAuth2WebServer">Using OAuth 2.0 for Web Server Applications</a>.
</p>
<h3 id="installed">Installed applications</h3>
<p>
The Google OAuth 2.0 endpoint supports applications that are installed on devices such as computers, 
mobile devices, and tablets. When you register such an application through the 
<a href="https://cloud.google.com/console" target="_blank">Google Cloud Console</a>, 
you can select Android, iOS, Chrome, or "native" as the 
platform.</p>
<p>
The registration process will result in a client ID and, in some cases, a client secret, 
which you embed in the source code of your application. (In this context, the client secret 
is obviously not treated as a secret.) 
</p>
<p>The authorization sequence begins when your application redirects 
a browser to a Google URL; the URL includes query parameters that indicate the type of access 
being requested. Google handles the user authentication, session selection, and user consent. 
The result is an authorization code, which the application can exchange for
an access token and a refresh token.
</p>
<p>
The application should store the refresh token for 
future use and use the access token to access a Google API. Once the access token expires, the 
application uses the refresh token to obtain a new one.
</p>
<figure id="fig1">
<img alt="Your application sends a token request to the Google Authorization Server, receives an authorization code, 
exchanges the code for a token, and uses the token to call a Google API endpoint." height="377px" src="/accounts/images/webflow.png" width="364px"/>
</figure>
<p>
For more information, see <a href="/accounts/docs/OAuth2InstalledApp">Using OAuth 2.0 for Installed Applications</a>.
</p>
<h3 id="clientside">Client-side (JavaScript) applications</h3>
<p>
The Google OAuth 2.0 endpoint supports JavaScript applications that run in a browser.
</p>
<p>
The authorization sequence begins when your application redirects a browser to a Google URL; the URL 
includes query parameters that indicate the type of access 
being requested. Google handles the user authentication, session selection, and user consent.
</p>
<p>The result is an access token, which the client should validate before including it in a Google 
API request. When the token expires, the application repeats the process.
</p>
<figure id="fig2">
<img alt="Your JS application sends a token request to the Google Authorization Server, receives a token, 
validates the token, and uses the token to call a Google API endpoint." height="377px" src="/accounts/images/tokenflow.png" width="364px"/>
</figure>
<p>
For more information, see <a href="/accounts/docs/OAuth2UserAgent">Using OAuth 2.0 for Client-side Applications</a>.
</p>
<h3 id="device">Applications on limited-input devices</h3>
<p>
The Google OAuth 2.0 endpoint supports applications that run on limited-input devices 
such as game consoles, video cameras, and printers. </p>
<p>The authorization sequence begins with the application making 
a web service request to a Google URL for an authorization code. The response contains several parameters, including a URL and
a code that the application shows to the user.
</p>
<p>
The user obtains the URL and code from the device, then switches to a separate device or computer with 
richer input capabilities. The user launches a browser, navigates to the specified URL, logs in, and enters the code.
</p>
<p>Meanwhile, the application polls a Google URL at a specified interval. After the user approves access, 
the response from the Google server contains an access token and refresh token. The application should store the refresh token for 
future use and use the access token to access a Google API. Once the access token expires, the 
application uses the refresh token to obtain a new one.
</p>
<figure id="fig3">
<img alt="The user logs in on a separate device that has a browser." height="423px" src="/accounts/images/deviceflow.png" width="451px"/>
</figure>
<p>For more information, see <a href="/accounts/docs/OAuth2ForDevices">Using OAuth 2.0 for Devices</a>.</p>
<h3 id="serviceaccount">Service accounts</h3>
<p>
Google APIs such as the Prediction API and Google Cloud Storage can act on behalf of an application 
without accessing user information. When an application accesses these APIs, the application needs to 
prove its own identity, but there is no need to gain a user's approval. In enterprise scenarios, 
an application can request delegated access to some resources. Google’s OAuth 2.0 endpoint supports 
these types of server-to-server interactions.
</p>
<aside class="note">
<b>Note:</b> This scenario requires applications to create and cryptographically sign JSON Web Tokens (JWTs). 
We strongly encourage you to use a library to perform these tasks. Writing this code without the use 
of a library that abstracts token creation and signing is prone to errors that can have a severe impact 
on the security of your application. For a list of libraries that support this scenario, see the 
<a href="/accounts/docs/OAuth2ServiceAccount">service-account documentation</a>.
</aside>
<p>
You will need a service account for this scenario. If you are using Google App Engine, a service account 
is created automatically for you; if not, you create a service account when you register the application 
through the <a href="https://cloud.google.com/console" target="_blank">Google Cloud Console</a>.
</p>
<p>Once the service account is created, you have access to 
the private key and a client ID. You use the private key and client ID to create a signed JWT and construct an access-token request 
in the appropriate format. Your 
application then sends the token request to the Google OAuth 2.0 Authorization Server, which returns an 
access token. The application uses the token to access a Google API. When the token 
expires, the application repeats the process.
</p>
<figure id="fig4">
<img alt="Your server application uses a JWT to request a token from the Google Authorization Server, 
then uses the token to call a Google API endpoint. No end-user is involved." height="302px" src="/accounts/images/serviceaccount.png" width="325px"/>
</figure>
<p>
For more information, see the <a href="/accounts/docs/OAuth2ServiceAccount">service-account documentation</a>.
</p>
</div></article>